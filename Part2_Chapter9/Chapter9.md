# Chapter 9 virtual memory

标签（空格分隔）： 学习笔记

---

### 9.8 My_Question:
一个共享库被映射到了多个程序的虚拟空间，假设其中一个程序更改这个共享库的代码，会发生什么？

答：如果一个程序尝试更改共享库的代码，它将会因违规操作而崩溃。  
对于库中的可写数据，每个程序实际上有其自己的私有副本，所以它们的更改不会影响其他使用该共享库的程序。

### 练习 9.5
其实就是熟悉Mmap函数的使用

### 关于malloc的一些笔记

> 程序结束以后，他所使用的malloc分配的内存是不是被操作系统回收了？

ChatGPT
是的，当一个进程结束时，操作系统会回收该进程使用的所有资源，包括通过 malloc()（以及相关函数如 calloc(), realloc() 等）分配的动态内存。

在程序运行期间，使用 free() 函数显式释放动态分配的内存是很重要的，以避免内存泄漏。但如果一个进程结束（无论是正常结束还是因为某种错误而崩溃），操作系统将负责清理所有剩余的分配的内存。这是操作系统资源管理的基本功能之一，确保资源如内存、文件描述符等在进程结束后得到正确的回收和重新利用。

然而，即使操作系统会在进程结束时自动清理内存，仍然强烈建议程序员在程序中适当地管理和释放内存，以保持良好的编程习惯，避免在长时间运行的程序中出现内存泄漏。

> 既然程序结束以后malloc分配的内存都会被操作系统回收，那么操作系统的垃圾回收机制还有什么意义？

你提到的“操作系统的垃圾回收机制”可能容易与某些编程语言中的垃圾回收机制混淆。让我们澄清一下：

操作系统资源管理：

当一个进程结束时，操作系统确实会回收这个进程使用的所有资源（如内存、文件描述符、套接字等）。
这不是“垃圾回收”机制，而是操作系统的基本资源管理功能。这确保了当一个进程结束时不会有资源泄露，从而允许长时间稳定地运行多个进程。
编程语言的垃圾回收：

垃圾回收（Garbage Collection, GC）通常与某些编程语言（如Java、C#、Python等）相关联。GC的目的是在程序运行时自动识别并回收不再被使用的内存，以减轻程序员的负担。
在没有GC的环境中（如C或C++），程序员需要显式地分配和释放内存，这可能会导致错误如内存泄漏、双重释放等。而GC旨在自动化这一过程，从而降低出错的可能性。
所以，回到你的问题：既然进程结束后操作系统会回收所有资源，那为什么还需要垃圾回收？

答案在于进程的生命周期。许多应用程序（尤其是服务器应用程序、长时间运行的守护进程、大型桌面应用等）可能会运行很长时间，甚至几天、几周或更长。如果这些应用程序持续分配内存但不释放不再使用的部分，它们最终可能会耗尽所有可用内存，导致性能下降或崩溃。垃圾回收的存在是为了在程序运行时自动管理这种内存使用，以确保长时间运行的程序不会因内存泄漏等问题而受到影响。

简而言之，操作系统确保进程结束时资源得到回收，而垃圾回收确保程序在其生命周期中有效地管理内存。


> User 假设某Linux系统的页大小是4KB，那么我想分配一个4字节大小的内存空间给某个程序，这样会不会造成很大的浪费？

ChatGPT
当在Linux系统（或其他类Unix系统）上使用像malloc()这样的函数分配小块内存时，实际的物理内存并不是直接为这个小块请求分配的。而是由于内存管理和分配策略的存在，这种小的请求会比较高效地被处理，而不会造成你想象的那种浪费。以下是背后的一些细节：

分页：虽然内存是按页（例如4KB）管理的，但这并不意味着每次小块内存分配都会消耗一个完整的页。大多数现代操作系统都不会为小的分配请求分配一个完整的页。

内存池和块：C语言的malloc()和类似的函数通常使用内存池技术。这意味着，当第一次调用malloc()或相关函数时，它可能会从操作系统请求一个或多个页的内存。然后，当应用程序请求小块内存时，malloc()会从这些已分配的页中分出小块来满足请求，而不是每次都向操作系统请求新页。

碎片管理：为了避免小块内存分配和释放导致的内存碎片，malloc()和它的相关函数使用了各种策略和技术，如块合并、块分割等，以高效地管理内存。

开销：尽管小块内存分配通常不会浪费大量内存，但它仍然有一些开销。例如，malloc()需要存储关于分配块的信息（如块的大小、状态等）。但这些开销通常远小于一个完整页的大小。

所以，虽然页的大小是4KB，但为程序分配4字节的内存并不会直接浪费4KB。相反，内存管理器会尽量确保这种小的分配是高效且节省资源的。但如果程序频繁地进行小块内存的分配和释放，那么随着时间的推移，可能会遇到内存碎片化的问题，这也是为什么内存池和其他高级内存管理策略在某些应用中是很有价值的。


> User 那操作系统是如何分配小块内存的呢？

ChatGPT
操作系统（和高级库，如C库中的malloc()）使用了一系列的技术和策略来高效地分配和管理小块内存。以下是这些方法的简要概述：

伙伴系统 (Buddy System)：这是一种常用于内核内存分配的方法。这种系统将内存块划分为大小为2的幂的块。当请求一个大小为n的内存块时，系统会分配一个大小为最接近（并大于或等于）n的2的幂的块。伙伴系统可以快速地合并（coalesce）和分割（split）块，从而提供快速的内存分配和回收。

滨 (Bins)：为了提高小块内存的分配效率，malloc()常常使用一个滨的方法。每个滨包含特定大小的内存块。例如，一个滨可能只包含64字节的块，另一个滨可能只包含128字节的块。当一个特定大小的块被请求时，它可以快速地从相应的滨中被提取出来。

内存池 (Memory Pools)：对于频繁分配和释放的小块内存，内存池是一个有效的策略。它事先分配一个大块的内存，然后从中提供小块的分配。这可以减少与操作系统的交互，并减少内存碎片。

延迟合并 (Lazy Coalescing)：为了减少碎片化和提高效率，free()可能不会立即返回内存块到操作系统。相反，它会标记这些块为可用，并尝试与相邻的自由块合并。只有当形成了一个大块时，它才可能被返回到操作系统。

分段 (Slabs)：这是另一种专门用于内核内存分配的方法，特别是针对某些常用的对象大小（如特定的内核数据结构）。Slab分配器将内存划分为称为“slabs”的块，这些块包含特定类型的对象。

页颜色 (Page Coloring)：这是一种考虑CPU缓存的分配策略。它的目的是使连续的内存分配更有可能位于同一个或相邻的CPU缓存行上，从而提高缓存利用率。

在实际应用中，小块内存的分配策略可能因操作系统、库版本、配置和其他因素而异。不过，上面提到的这些方法为实现高效的内存管理提供了基础。

### homework

9.11
### A

|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
|--|--|--|--|--|--|--|--|--|--|--|--|--|--|
| 0| 0| 0| 0| 1| 0| 0| 1| 1| 1| 1| 1| 0| 0|

### B

|parament|value|
|:-:|:-:|
|VPN|0x09	|
|TLBI|0x01	|
|TLBT|0x02	|
|hit?|no	|
|page fault?|no	|
|PPN|0x17	|

### C

|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
|--|--|--|--|--|--|--|--|--|--|--|--|
| 0| 1| 0| 1| 1| 1| 1| 1| 1| 1| 0| 0|

### D

|parament|value|
|:-:|:-:|
|CO|0x00	|
|CI|0x0f	|
|CT|0x17	|
|hit?|no	|
|value|--	|

9.14
其实就是mmap的返回地址用数组接住，然后修改此数组的第一个元素即可，详细见mmap_hello.c







